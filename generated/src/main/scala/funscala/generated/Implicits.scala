/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package funscala.generated
import cats.syntax.either._
import io.circe.syntax._
import cats.instances.all._
import cats.implicits._
import cats.data.EitherT
object Implicits {
  abstract class AddArg[T] { def addArg(key: String, v: T): String }
  object AddArg {
    def build[T](f: String => T => String): AddArg[T] = new AddArg[T] { def addArg(key: String, v: T): String = f(key)(v) }
    implicit def addArgSeq[T](implicit ev: AddArg[T]): AddArg[Seq[T]] = build[Seq[T]](key => vs => vs.map(v => ev.addArg(key, v)).mkString("&"))
    implicit def addArgIndexedSeq[T](implicit ev: AddArg[T]): AddArg[IndexedSeq[T]] = build[IndexedSeq[T]](key => vs => vs.map(v => ev.addArg(key, v)).mkString("&"))
    implicit def addArgIterable[T](implicit ev: AddArg[T]): AddArg[Iterable[T]] = build[Iterable[T]](key => vs => vs.map(v => ev.addArg(key, v)).mkString("&"))
    implicit def addArgList[T](implicit ev: AddArg[T]): AddArg[List[T]] = build[List[T]](key => vs => vs.map(v => ev.addArg(key, v)).mkString("&"))
    implicit def addArgVector[T](implicit ev: AddArg[T]): AddArg[Vector[T]] = build[Vector[T]](key => vs => vs.map(v => ev.addArg(key, v)).mkString("&"))
    implicit def addArgOption[T](implicit ev: AddArg[T]): AddArg[Option[T]] = build[Option[T]](key => v => v.map(ev.addArg(key, _)).getOrElse(""))
  }
  abstract class AddPath[T] { def addPath(v: T): String }
  object AddPath { def build[T](f: T => String): AddPath[T] = new AddPath[T] { def addPath(v: T): String = f(v) } }
  abstract class Show[T] { self =>
    def show(v: T): String
    def contramap[A](f: A => T): Show[A] = new Show[A] { def show(v: A): String = self.show(f(v)) }
  }
  object Show {
    def apply[A](implicit ev: Show[A]): Show[A] = ev
    def build[T](f: T => String): Show[T] = new Show[T] { def show(v: T): String = f(v) }
    implicit val showString: Show[String] = build[String](Predef.identity)
    implicit val showInt: Show[Int] = build[Int](_.toString)
    implicit val showLong: Show[Long] = build[Long](_.toString)
    implicit val showFloat: Show[Float] = build[Float](_.toString)
    implicit val showDouble: Show[Double] = build[Double](_.toString)
    implicit val showBigInt: Show[BigInt] = build[BigInt](_.toString)
    implicit val showBigDecimal: Show[BigDecimal] = build[BigDecimal](_.toString)
    implicit val showBoolean: Show[Boolean] = build[Boolean](_.toString)
    implicit val showLocalDate: Show[java.time.LocalDate] = build(_.format(java.time.format.DateTimeFormatter.ISO_DATE))
    implicit val showOffsetDateTime: Show[java.time.OffsetDateTime] = build(_.format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME))
    implicit val showJavaURL: Show[java.net.URI] = build(_.toString)
    implicit val showUUID: Show[java.util.UUID] = build(_.toString)
  }
  object Formatter {
    def show[T](value: T)(implicit ev: Show[T]): String = {
      ev.show(value)
    }
    def addArg[T](key: String, value: T)(implicit ev: AddArg[T]): String = {
      s"&${ev.addArg(key, value)}"
    }
    def addPath[T](value: T)(implicit ev: AddPath[T]): String = {
      ev.addPath(value)
    }
  }
  class Base64String(val data: Array[Byte]) extends AnyVal { override def toString() = "Base64String(" + data.toString() + ")" }
  object Base64String {
    def apply(bytes: Array[Byte]): Base64String = new Base64String(bytes)
    def unapply(value: Base64String): Some[Array[Byte]] = Some(value.data)
  }
}