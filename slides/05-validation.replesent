:ballot_box_with_check: Option
:ballot_box_with_check: Refined types
:ballot_box_with_check: "Type classes"
:ballot_box: Validation
---
```
sealed trait Validation[+Err, +A]
case class Success[A](value: A) extends Validation[Nothing, A]
case class Failure[E](value: E) extends Validation[E, Nothing]
--

type ValidOrErrorStrings[+A] = Validation[List[String], A]
def success[T](x: T): ValidOrErrorStrings[T] = Success(x)
def fail[T](err: String): ValidOrErrorStrings[T] = Failure(List(err))
--

trait Context[F[_]] {
  def wrap[A](value: A): F[A]
  def call[A, B](fa: => F[A])(ff: F[A => B]): F[B]

  def lift[A, Result](f: A => Result): F[A] => F[Result] = {
    case fa =>

    call(fa)(wrap(f))
  }
}
```
---
```
implicit object ValidationContext extends Context[ValidOrErrorStrings] {
  def wrap[A](value: A) = Success(value)
  def call[A, B](fa: => ValidOrErrorStrings[A])(ff: ValidOrErrorStrings[A => B]): ValidOrErrorStrings[B] = {
    (fa, ff) match {
      case (Success(a), Success(f)) => Success(f(a))
      case (Failure(a), Failure(f)) => Failure(f ++ a)
      case (Failure(a), _) => Failure(a)
      case (_, Failure(f)) => Failure(f)
    }
  }
}
```
--
```

def addTwo[F[_]](value: F[Int])(implicit ctx: Context[F]) = {
  ctx.call(value)(ctx.wrap((_: Int) + 2))
}
--

addTwo(success(2))
--

addTwo(fail[Int]("Something terrible happened!"))
```
---
```
type RawUsername = String
object Username extends Tagger[String]
type Username = Username.Type

val validateUsername: RawUsername => ValidOrErrorStrings[Username] = {
  case "" => "Username must not be empty!".failureNel

  case x if Set("foo", "bar", "baz").contains(x) =>
    s"${x} is not a valid username!".failureNel

  case x if x.length > 16 => "Username is too long!".failureNel

  case valid => Username(valid).successNel
}
```
---
```
import uk.gov.hmrc.emailaddress.EmailAddress
type RawEmail = String
object Email extends Tagger[String]
type Email = Email.Type

val validateEmail: RawEmail => ValidOrErrorStrings[Email] = {
  case "" => "Email must not be empty!".failureNel

  case x if x.endsWith("@example.com") =>
    "Please use a valid domain!".failureNel

  case x if !EmailAddress.isValid(x) => "Invalid email!".failureNel

  case valid => Email(valid).successNel
}
```
---
```
type RawAge = Int
object Age extends Tagger[Int]
type Age = Age.Type

val validateAge: RawAge => ValidOrErrorStrings[Age] = {
  case x if x < 0 => "Invalid age!".failureNel
  case valid => Age(valid).successNel
}
```
---
```
type RawFirstName = String
object FirstName extends Tagger[String]
type FirstName = FirstName.Type

type RawLastName = String
object LastName extends Tagger[String]
type LastName = LastName.Type

def validateString[T](wrap: String => T
    ): String => ValidOrErrorStrings[T] = {
  case "" => "Must not be empty!".failureNel
  case x if x.length > 16 => "Maximum length of 16 characters".failureNel
  case valid => wrap(valid).successNel
}

val validateFirstName: RawFirstName => ValidOrErrorStrings[FirstName] =
  validateString(FirstName(_))
val validateLastName: RawLastName => ValidOrErrorStrings[LastName] =
  validateString(LastName(_))
```
---
```
case class User(id: Long, username: Username, email: Email,
    age: Age, firstName: FirstName, lastName: LastName)

def createUser(id: Long, username: RawUsername, email: RawEmail,
    age: RawAge, firstName: RawFirstName, lastName: RawLastName
    ): ValidOrErrorStrings[User] = {
  val ValidUser = Applicative[ValidOrErrorStrings].lift6(User)

  ValidUser(
    id.successNel,
    validateUsername(username),
    validateEmail(email),
    validateAge(age),
    validateFirstName(firstName),
    validateLastName(lastName)
  )
}
```
---
```
val validUser = createUser(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser = createUser(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
```
---
# Surely, we can improve on this.
--
```
case class User2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String)
```
# No need for refined types
---
```
val validateUsername: String => Either[String, String] = {
  case "" => Left("Username must not be empty!")
  case x if Set("foo", "bar", "baz").contains(x) => Left("${x} is not a valid username!")
  case x if x.length > 16 => Left("Username is too long!")
  case valid => Right(valid)
}
```
# Either is part of the standard library
--
```
val validateEmail: String => Either[String, String] = {
  case "" => Left("Email must not be empty!")
  case x if x.endsWith("@example.com") => Left("Please use a valid domain!")
  case x if !EmailAddress.isValid(x) => Left("Invalid email!")
  case valid => Right(valid)
}
```
---
```
val validateAge: Int => Either[String, Int] = {
  case x if x < 0 => Left("Invalid age!")
  case valid => Right(valid)
}

val validateName: String => Either[String, String] = {
  case "" => Left("Must not be empty!")
  case x if x.length > 16 => Left("Maximum length of 16 characters")
  case valid => Right(valid)
}
```
---
```
def createUser2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] =








```
---
```
def createUser2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] = {

  val _username = validateUsername(username)
  val _email = validateEmail(email)
  val _age = validateAge(age)
  val _firstName = validateName(firstName)
  val _lastName = validateName(lastName)

  val errors: List[String] = List(
    _username.left.toOption,
    _email.left.toOption,
    _age.left.toOption,
    _firstName.left.toOption,
    _lastName.left.toOption
  ).flatten

  if (errors.isEmpty) {
    Right(User2(id, _username.right.get, _email.right.get,
      _age.right.get, _firstName.right.get, _lastName.right.get))
  } else {
    Left(errors)
  }
}
```
---
It works though!

```
val validUser2 = createUser2(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser2 = createUser2(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
---
