:ballot_box_with_check: Option
:ballot_box_with_check: Refined types
:ballot_box_with_check: "Type classes"
:ballot_box: Validation
---
Applicative:
  point: A => F[A]
  ap: F[A] => F[A => B] => F[B]
--
  lift:  ( A      => B) =>  F[A]              => F[B]
--
  lift2: ((A,B)   => C) => (F[A], F[B])       => F[C]
--
  lift3: ((A,B,C) => D) => (F[A], F[B], F[C]) => F[D]
  ...
---
```
import scala.language.higherKinds
import scalaz._, Scalaz._

case class Simple[T](value: T)

implicit object ApplicativeSimple extends Applicative[Simple] {
  def point[A](a: => A): Simple[A] = Simple(a)
  def ap[A, B](fa: => Simple[A])(f: => Simple[A => B]): Simple[B] = Simple(f.value(fa.value))
}

def compute[F[_]: Applicative]: F[Long] = {
  def pure[T](value: T): F[T] = Applicative[F].pure(value)
  def add(a: F[Long], b: F[Long]): F[Long] = (a |@| b) { _ + _ }

  add(pure(10L), pure(20L))
}
```
---
```
type ValidOrErrorStrings[T] = Validation[NonEmptyList[String], T]

compute[ValidOrErrorStrings] |+| 20L.successNel
```
--
```
compute[ValidOrErrorStrings] |+| "An error occurred!".failureNel
```
---
```
type RawUsername = String
object Username extends Tagger[String]
type Username = Username.Type

val validateUsername: RawUsername => ValidOrErrorStrings[Username] = {
  case "" => "Username must not be empty!".failureNel

  case x if Set("foo", "bar", "baz").contains(x) =>
    s"${x} is not a valid username!".failureNel

  case x if x.length > 16 => "Username is too long!".failureNel

  case valid => Username(valid).successNel
}
```
---
```
import uk.gov.hmrc.emailaddress.EmailAddress
type RawEmail = String
object Email extends Tagger[String]
type Email = Email.Type

val validateEmail: RawEmail => ValidOrErrorStrings[Email] = {
  case "" => "Email must not be empty!".failureNel

  case x if x.endsWith("@example.com") =>
    "Please use a valid domain!".failureNel

  case x if !EmailAddress.isValid(x) => "Invalid email!".failureNel

  case valid => Email(valid).successNel
}
```
---
```
case class User(id: Long, username: Username, email: Email)

def createUser(id: Long, username: RawUsername, email: RawEmail
    ): ValidOrErrorStrings[User] = {
  val ValidUser = Applicative[ValidOrErrorStrings].lift3(User)

  ValidUser(
    id.successNel,
    validateUsername(username),
    validateEmail(email)
  )
}
```
--

```
val validUser = createUser(123L, "neo", "tanderson@metacortex.com")
```
--

```
val invalidUser = createUser(123L, "foo", "bar@example.com")
```
---
