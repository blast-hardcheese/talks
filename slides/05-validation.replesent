:ballot_box_with_check: Option
:ballot_box_with_check: Refined types
:ballot_box_with_check: "Type classes"
:ballot_box: Validation
---
Applicative:
  point: A => F[A]
  ap: F[A] => F[A => B] => F[B]
--
  lift:  ( A      => B) =>  F[A]              => F[B]
--
  lift2: ((A,B)   => C) => (F[A], F[B])       => F[C]
--
  lift3: ((A,B,C) => D) => (F[A], F[B], F[C]) => F[D]
  ...
---
```
import scala.language.higherKinds
import scalaz._, Scalaz._

case class Simple[T](value: T)

implicit object ApplicativeSimple extends Applicative[Simple] {
  def point[A](a: => A): Simple[A] = Simple(a)
  def ap[A, B](fa: => Simple[A])(f: => Simple[A => B]): Simple[B] = Simple(f.value(fa.value))
}

def compute[F[_]: Applicative]: F[Long] = {
  def pure[T](value: T): F[T] = Applicative[F].pure(value)
  def add(a: F[Long], b: F[Long]): F[Long] = (a |@| b) { _ + _ }

  add(pure(10L), pure(20L))
}
```
---
```
type ValidOrErrorStrings[T] = Validation[NonEmptyList[String], T]

compute[ValidOrErrorStrings] |+| 20L.successNel
```
--
```
compute[ValidOrErrorStrings] |+| "An error occurred!".failureNel
```
---
```
type RawUsername = String
object Username extends Tagger[String]
type Username = Username.Type

val validateUsername: RawUsername => ValidOrErrorStrings[Username] = {
  case "" => "Username must not be empty!".failureNel

  case x if Set("foo", "bar", "baz").contains(x) =>
    s"${x} is not a valid username!".failureNel

  case x if x.length > 16 => "Username is too long!".failureNel

  case valid => Username(valid).successNel
}
```
---
```
import uk.gov.hmrc.emailaddress.EmailAddress
type RawEmail = String
object Email extends Tagger[String]
type Email = Email.Type

val validateEmail: RawEmail => ValidOrErrorStrings[Email] = {
  case "" => "Email must not be empty!".failureNel

  case x if x.endsWith("@example.com") =>
    "Please use a valid domain!".failureNel

  case x if !EmailAddress.isValid(x) => "Invalid email!".failureNel

  case valid => Email(valid).successNel
}
```
---
```
type RawAge = Int
object Age extends Tagger[Int]
type Age = Age.Type

val validateAge: RawAge => ValidOrErrorStrings[Age] = {
  case x if x < 0 => "Invalid age!".failureNel
  case valid => Age(valid).successNel
}
```
---
```
type RawFirstName = String
object FirstName extends Tagger[String]
type FirstName = FirstName.Type

type RawLastName = String
object LastName extends Tagger[String]
type LastName = LastName.Type

def validateString[T](wrap: String => T
    ): String => ValidOrErrorStrings[T] = {
  case "" => "Must not be empty!".failureNel
  case x if x.length > 16 => "Maximum length of 16 characters".failureNel
  case valid => wrap(valid).successNel
}

val validateFirstName: RawFirstName => ValidOrErrorStrings[FirstName] =
  validateString(FirstName(_))
val validateLastName: RawLastName => ValidOrErrorStrings[LastName] =
  validateString(LastName(_))
```
---
```
case class User(id: Long, username: Username, email: Email,
    age: Age, firstName: FirstName, lastName: LastName)

def createUser(id: Long, username: RawUsername, email: RawEmail,
    age: RawAge, firstName: RawFirstName, lastName: RawLastName
    ): ValidOrErrorStrings[User] = {
  val ValidUser = Applicative[ValidOrErrorStrings].lift6(User)

  ValidUser(
    id.successNel,
    validateUsername(username),
    validateEmail(email),
    validateAge(age),
    validateFirstName(firstName),
    validateLastName(lastName)
  )
}
```
---
```
val validUser = createUser(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser = createUser(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
```
---
# Surely, we can improve on this.
--
```
case class User2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String)
```
# No need for refined types
---
```
val validateUsername: String => Either[String, String] = {
  case "" => Left("Username must not be empty!")
  case x if Set("foo", "bar", "baz").contains(x) => Left("${x} is not a valid username!")
  case x if x.length > 16 => Left("Username is too long!")
  case valid => Right(valid)
}
```
# Either is part of the standard library
--
```
val validateEmail: String => Either[String, String] = {
  case "" => Left("Email must not be empty!")
  case x if x.endsWith("@example.com") => Left("Please use a valid domain!")
  case x if !EmailAddress.isValid(x) => Left("Invalid email!")
  case valid => Right(valid)
}
```
---
```
val validateAge: Int => Either[String, Int] = {
  case x if x < 0 => Left("Invalid age!")
  case valid => Right(valid)
}

val validateName: String => Either[String, String] = {
  case "" => Left("Must not be empty!")
  case x if x.length > 16 => Left("Maximum length of 16 characters")
  case valid => Right(valid)
}
```
---
```
def createUser2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] =








```
---
```
def createUser2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] = {

  val _username = validateUsername(username)
  val _email = validateEmail(email)
  val _age = validateAge(age)
  val _firstName = validateName(firstName)
  val _lastName = validateName(lastName)

  val errors: List[String] = List(
    _username.left.toOption,
    _email.left.toOption,
    _age.left.toOption,
    _firstName.left.toOption,
    _lastName.left.toOption
  ).flatten

  if (errors.isEmpty) {
    Right(User2(id, _username.right.get, _email.right.get,
      _age.right.get, _firstName.right.get, _lastName.right.get))
  } else {
    Left(errors)
  }
}
```
---
It works though!

```
val validUser2 = createUser2(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser2 = createUser2(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
---
