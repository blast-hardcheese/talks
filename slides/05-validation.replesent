:ballot_box_with_check: Option
:ballot_box_with_check: Refined types
:ballot_box_with_check: "Type classes"
:ballot_box: Validation
---
```
sealed trait Validation[+Err, +A]
case class Success[A](value: A) extends Validation[Nothing, A]
case class Failure[E](value: E) extends Validation[E, Nothing]
```
--

```
type ValidOrErrorStrings[+A] = Validation[List[String], A]
```
--

```
def success[T](x: T): ValidOrErrorStrings[T] = Success(x)
def fail[T](err: String): ValidOrErrorStrings[T] = Failure(List(err))
```
---

```
trait Applicative[F[_]] {
  type Ctx[T] = F[T]

  def wrap[A](value: A): F[A]
  def call[A, B](fa: => F[A])(ff: F[A => B]): F[B]

  def lift[A, Result](f: A => Result): F[A] => F[Result] = {
    case fa =>

    call(fa)(wrap(f))
  }
}
```
---
```
//!/*
buildLift(6)
//!*/
```
---
```
implicit object ValidationContext extends Applicative[ValidOrErrorStrings] {
  def wrap[A](value: A) = Success(value)
  def call[A, B](fa: => Ctx[A])(ff: Ctx[A => B]): Ctx[B] = {
    (fa, ff) match {
      case (Success(a), Success(f)) => Success(f(a))
      case (Failure(a), Failure(f)) => Failure(f ++ a)
      case (Failure(a), _) => Failure(a)
      case (_, Failure(f)) => Failure(f)
    }
  }
}
```
--

```
def addTwo[F[_]](value: F[Int])(implicit ctx: Applicative[F]) = {
  ctx.call(value)(ctx.wrap((_: Int) + 2))
}
```
--

```
//!/*
addTwo(success(2))
//!*/
```
--

```
//!/*
addTwo(fail[Int]("Something terrible happened!"))
//!*/
```
---
```
object Username extends Tagger[String]
type Username = Username.Type

type RawUsername = String

val validateUsername: RawUsername => ValidOrErrorStrings[Username] = {
  case "" => fail("Username must not be empty!")

  case x if Set("foo", "bar", "baz").contains(x) =>
    fail(s"${x} is not a valid username!")

  case x if x.length > 16 => fail("Username is too long!")

  case valid => success(Username(valid))
}
```
---
```
import uk.gov.hmrc.emailaddress.EmailAddress
type RawEmail = String
object Email extends Tagger[String]
type Email = Email.Type

val validateEmail: RawEmail => ValidOrErrorStrings[Email] = {
  case "" => fail("Email must not be empty!")

  case x if x.endsWith("@example.com") =>
    fail("Please use a valid domain!")

  case x if !EmailAddress.isValid(x) => fail("Invalid email!")

  case valid => success(Email(valid))
}
```
---
```
type RawAge = Int
object Age extends Tagger[Int]
type Age = Age.Type

val validateAge: RawAge => ValidOrErrorStrings[Age] = {
  case x if x < 0 => fail("Invalid age!")
  case valid => success(Age(valid))
}
```
---
```
//-Defined in previous slides
type RawFirstName = String
//+object FirstName extends Tagger[String]
//+type FirstName = FirstName.Type

type RawLastName = String
//+object LastName extends Tagger[String]
//+type LastName = LastName.Type

def validateString[T](wrap: String => T
    ): String => ValidOrErrorStrings[T] = {
  case "" => fail("Must not be empty!")
  case x if x.length > 16 => fail("Maximum length of 16 characters")
  case valid => success(wrap(valid))
}

val validateFirstName: RawFirstName => ValidOrErrorStrings[FirstName] =
  validateString(FirstName(_))
val validateLastName: RawLastName => ValidOrErrorStrings[LastName] =
  validateString(LastName(_))
```
---
```
case class User(id: Long, username: Username, email: Email,
    age: Age, firstName: FirstName, lastName: LastName)

def createUser(id: Long, username: RawUsername, email: RawEmail,
    age: RawAge, firstName: RawFirstName, lastName: RawLastName
    ): ValidOrErrorStrings[User] = {
  val ValidUser = ValidationContext.lift6(User)

  ValidUser(
    success(id),
    validateUsername(username),
    validateEmail(email),
    validateAge(age),
    validateFirstName(firstName),
    validateLastName(lastName)
  )
}
```
---
```
val validUser = createUser(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser = createUser(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
```
---
# Surely, we can improve on this.
--
```
case class User2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String)
```
# No need for refined types
---
```
val validateUsername2: String => Either[String, String] = {
  case "" => Left("Username must not be empty!")
  case x if Set("foo", "bar", "baz").contains(x) => Left("${x} is not a valid username!")
  case x if x.length > 16 => Left("Username is too long!")
  case valid => Right(valid)
}
```
# Either is part of the standard library
--
```
val validateEmail2: String => Either[String, String] = {
  case "" => Left("Email must not be empty!")
  case x if x.endsWith("@example.com") => Left("Please use a valid domain!")
  case x if !EmailAddress.isValid(x) => Left("Invalid email!")
  case valid => Right(valid)
}
```
---
```
val validateAge2: Int => Either[String, Int] = {
  case x if x < 0 => Left("Invalid age!")
  case valid => Right(valid)
}

val validateName: String => Either[String, String] = {
  case "" => Left("Must not be empty!")
  case x if x.length > 16 => Left("Maximum length of 16 characters")
  case valid => Right(valid)
}
```
---
```
def createUser_(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] = ???
```
---
```
def createUser2(id: Long, username: String, email: String,
    age: Int, firstName: String, lastName: String
    ): Either[List[String], User2] = {

  val _username = validateUsername2(username)
  val _email = validateEmail2(email)
  val _age = validateAge2(age)
  val _firstName = validateName(firstName)
  val _lastName = validateName(lastName)

  val errors: List[String] = List(
    _username.left.toOption,
    _email.left.toOption,
    _age.left.toOption,
    _firstName.left.toOption,
    _lastName.left.toOption
  ).flatten

  if (errors.isEmpty) {
    Right(User2(id, _username.right.get, _email.right.get,
      _age.right.get, _firstName.right.get, _lastName.right.get))
  } else {
    Left(errors)
  }
}
```
---
It works though!

```
val validUser2 = createUser2(123L, "neo", "tanderson@metacortex.com",
    32, "Thomas", "Anderson")
```
--

```
val invalidUser2 = createUser2(123L, "foo", "bar@example.com",
    -100, "Somebody", "")
```
---
